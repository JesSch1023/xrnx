--[[============================================================================
xStream
============================================================================]]--
--[[

  ### About xStream

  xStream creates a continuous stream of automation or pattern data that
  you can control in realtime. 

  The stream is generated by a single callback method. The callback will 
  usually be asked to create output for a number of lines at a time. This 
  should ensure that there's actually something to play as playback
  progresses through the song, across patterns or within loops.

  ## Pitfalls, things that might not work as expected

  + Changing position near the end of a pattern might throw the offset off
  + "Crazy navigation" in general is hard to track. In the current state,
    it is recommended to work with regular scheduling of patterns, looping
    (including block-looping). It is certainly stable enough for normal
    playback, but jumping around sporadically _could_ throw things off.
  + Can under some circumstances fail in creating automation lanes. 
    This is why the current implementation supports only a single parameter.

]]

class 'xStream'

xStream.PLAYMODE = {
  POINTS = 1,
  LINEAR = 2,
  CUBIC = 3,
}

--- choose a mute mode
-- NONE = do nothing except to output 'nothing'
--    note: when combined with 'clear', this makes it possible to 
--    record into a track, using the mute button as a 'output switch'
-- OFF = insert OFF across columns, then nothing
--    TODO when 'clear_undefined' is true, OFF is only written when
--    there is not an existing note at that position
xStream.MUTE_MODE = {
  NONE = 1,
  OFF = 2,
}

xStream.MUTE_MODES = {"NONE","OFF"}

-------------------------------------------------------------------------------
-- constructor

function xStream:__init()

  -- xStreamUI, built-in user interface
  self.ui = nil

  -- int, writeahead amount
  self.writeahead = nil

  -- table<xLine>, output buffer
  self.buffer = {}

  -- Content is read from the pattern as new content is requested from the 
  -- callback method - this ensures that the callback always has a
  -- fully populated line to work on. But unlike the output buffer, the
  -- read buffer is not cleared when arguments change - it should be read
  -- only *once*. 
  -- table<xLine descriptor>, input buffer
  self.read_buffer = {}

  -- int, keep track of the highest/lowest line in our buffers
  self.highest_buffer_idx = 0
  self.lowest_buffer_idx = 0

  -- xSongPos.OUT_OF_BOUNDS, handle song boundaries
  self.bounds_mode = xSongPos.OUT_OF_BOUNDS.LOOP

  -- xSongPos.BLOCK_BOUNDARY, handle block boundaries
  self.block_mode = xSongPos.BLOCK_BOUNDARY.SOFT

  -- xSongPos.LOOP_BOUNDARY, handle pattern/seq.loop boundaries
  self.loop_mode = xSongPos.LOOP_BOUNDARY.SOFT

  -- (renoise.SongPos) monitor changes to playback 
  self._playpos = rns.transport.playback_pos

  -- (renoise.SongPos) monitor changes to playback 
  self._editpos = rns.transport.edit_pos

  -- (xSongPos) where we most recently read from the pattern
  self.next_read_pos = nil

  -- xStream.PLAYMODE (string-based enum)
  self.automation_playmode = xStream.PLAYMODE.LINEAR

  -- (xSongPos) created by the start() method, this is where
  -- we keep the overall progression of the stream 
  self._writepos = xSongPos(rns.transport.playback_pos)


  -- observable interface ---------------------------------
  
  -- int, decrease this if you are experiencing dropouts during heavy UI
  -- operations in Renoise (such as opening a plugin GUI) 
  self.writeahead_factor = 300

  -- string, value depends on success/failure during last callback 
  -- "" = no problem
  -- "Some error occurred" = description of error 
  self.callback_status_observable = renoise.Document.ObservableString("")

  -- bool, when true we compile the callback on-the-fly
  self.live_coding_observable = renoise.Document.ObservableBoolean(false)

  -- int, decide which track to target (0 = none)
  self.track_index = property(self.get_track_index,self.set_track_index)
  self.track_index_observable = renoise.Document.ObservableNumber(0)

  -- int, selected device in device chain (0 = none)
  self.device_index = property(self.get_device_index,self.set_device_index)
  self.device_index_observable = renoise.Document.ObservableNumber(0)

  -- renoise.AudioDevice, selected in device chain (can be nil)
  -- note: if you need observable, use device_index_observable
  self.device = property(self.get_device)
  self._device = nil 

  -- int, selected device parameter in automation (0 = none)
  self.param_index = property(self.get_param_index,self.set_param_index)
  self.param_index_observable = renoise.Document.ObservableNumber(0)

  -- boolean, whether to include hidden (not visible) columns
  self.include_hidden = property(
    self.get_include_hidden,self.set_include_hidden)
  self.include_hidden_observable = renoise.Document.ObservableBoolean(false)

  -- boolean, determine how to respond to 'undefined' content
  self.clear_undefined = property(
    self.get_clear_undefined,self.set_clear_undefined)
  self.clear_undefined_observable = renoise.Document.ObservableBoolean(true)

  -- boolean, whether to expand (sub-)columns when writing data
  self.expand_columns = property(
    self.get_expand_columns,self.set_expand_columns)
  self.expand_columns_observable = renoise.Document.ObservableBoolean(true)

  -- xStream.MUTE_MODE, controls how muting is done
  self.mute_mode = property(
    self.get_mute_mode,self.set_mute_mode)
  self.mute_mode_observable = renoise.Document.ObservableNumber(xStream.MUTE_MODE.OFF)

  -- bool, set to true to silence output
  self.muted = property(
    self.get_muted,self.set_muted)
  self.muted_observable = renoise.Document.ObservableBoolean(false)

  -- int, the line at which output got muted
  self.mute_pos = nil

  -- int, 'undefined' line to insert after output got muted 
  self.empty_xline = xLine({
    note_columns = {},
    effect_columns = {},
  })

  -- bool, true when we should output during live streaming 
  self.active = property(
    self.get_active,self.set_active)
  self.active_observable = renoise.Document.ObservableBoolean(false)

  -- table<xStreamModel>, registered models 
  self.models = {}

  -- table<int>, receive notification when models are added/removed
  -- the table itself contains just the model indices
  self.models_observable = renoise.Document.ObservableNumberList()

  -- int, the model index, 1-#models or 0 when none is selected
  self.selected_model_index = property(
    self.get_selected_model_index,self.set_selected_model_index)
  self.selected_model_index_observable = renoise.Document.ObservableNumber(0)

  -- xStreamModel, read-only - nil when no model is selected
  self.selected_model = nil

  -- string, last file path from where we imported models ('load_models')
  self.last_models_path = nil

  -- xStreamProxy, provides callback with 'real' constant values
  --self.proxy = xStreamProxy(self)

  -- number, or nil
  -- this is a short-lived timestamp indicating that we should ignore 
  -- changes to the playback position, right after playback has started
  -- (the fuzziness is due to API living in separate thread)
  self.just_started_playback = nil

  -- bool, true if we want xStream to manage garbage collection
  self.manage_gc = false

  -- initialize -----------------------

  self:determine_writeahead()

  -- always run during idle
  renoise.tool().app_idle_observable:add_notifier(function()
    self:on_idle()
  end)

end

-------------------------------------------------------------------------------
-- class methods
-------------------------------------------------------------------------------

function xStream:add_model(model)
  TRACE("xStream:add_model(model)")

  model.xstream = self
  table.insert(self.models,model)

  -- if first model, select it
  --[[
  if (#self.models == 1) then
    self.selected_model_index = 1
  end
  ]]

  self.models_observable:insert(#self.models)

end

-------------------------------------------------------------------------------
-- remove all models

function xStream:remove_models()
  TRACE("xStream:remove_models()")

  for k,v in ripairs(self.models) do
    self:remove_model(k)
  end 

end

-------------------------------------------------------------------------------
-- remove specific model from list
-- @param model_idx (int)

function xStream:remove_model(model_idx)
  TRACE("xStream:remove_model(model_idx)",model_idx)

  if (model_idx == self.selected_model_index) then
    if self.active then
      self:stop()
    end 
  end

  table.remove(self.models,model_idx)
  self.models_observable:remove(model_idx)

  if (self.selected_model_index == model_idx) then
    self.selected_model_index = 0
  end

end

-------------------------------------------------------------------------------
-- delete from disk, the remove from list
-- @param model_idx (int)
-- @return bool, true when we deleted the file
-- @return string, error message when failed

function xStream:delete_model(model_idx)
  TRACE("xStream:delete_model(model_idx)",model_idx)

  local model = self.models[model_idx]
  --print("model",model,"model.file_path",model.file_path)
  local success,err = os.remove(model.file_path)
  if not success then
    return false,err
  end

  self:remove_model(model_idx)

  return true

end




-------------------------------------------------------------------------------
-- load all models (files ending with .lua) in a given folder
-- log potential errors during parsing

function xStream:load_models(str_path)
  TRACE("xStream:load_models(str_path)",str_path)

  local log_msg = ""
  for _, filename in pairs(os.filenames(str_path, "*.lua")) do
    local model = xStreamModel(self)
    local model_file_path = str_path..filename
    local passed,err = model:load_definition(model_file_path)
    if not passed then
      log_msg = log_msg .. err .. "\n"
    else
      --print("Add model",filename)
      self:add_model(model)
    end
  end

  if (log_msg ~= "") then
     LOG(log_msg.."WARNING One or more models failed to load during startup")
  end

  -- select the first model, if any
  self.selected_model_index = (#self.models > 0) and 1 or 0

  -- save the path for later use
  -- (when creating 'virtual' models, this is where they will be saved)
  self.last_models_path = str_path

end

-------------------------------------------------------------------------------

function xStream:select_model_by_name(str_name)
  TRACE("xStream:select_model_by_name(str_name)",str_name)

  if not self.models then
    return 
  end

  for k,v in ipairs(self.models) do
    if (v.name == str_name) then
      self.selected_index = k
    end
  end

end

-------------------------------------------------------------------------------
-- get/set methods
-------------------------------------------------------------------------------

function xStream:get_selected_model_index()
  return self.selected_model_index_observable.value
end

-------------------------------------------------------------------------------

function xStream:set_selected_model_index(idx)
  TRACE("xStream:set_selected_model_index(idx)",idx)

  if (#self.models == 0) then
    error("there are no available models")
  end

  if (idx > #self.models) then
    error("selected_model_index needs to be between 1 and",#self.models)
  end

  if (idx == self.selected_model_index_observable.value) then
    --print("*** xStream:set_selected_model_index - same model, do nothing")
    return
  end
  
  -- remove notifiers from old model
  if self.selected_model then
    self.selected_model:detach_from_song()
  end

  -- !!! perform these steps before setting index
  self.selected_model = (idx > 0) and self.models[idx] or nil
  if self.selected_model then
    self.selected_model:attach_to_song()
  end

  self.selected_model_index_observable.value = idx
  self:wipe_futures()
  self:reset()

end

-------------------------------------------------------------------------------

function xStream:get_track_index()
  return self.track_index_observable.value
end

function xStream:set_track_index(val)
  self.track_index_observable.value = val
end

-------------------------------------------------------------------------------

function xStream:get_device_index()
  return self.device_index_observable.value
end

function xStream:set_device_index(val)
  self.device_index_observable.value = val
end

-------------------------------------------------------------------------------

function xStream:get_device()
  if self.track_index then
    return rns.tracks[self.track_index].devices[self.device_index]
  end
end

-------------------------------------------------------------------------------

function xStream:get_param_index()
  return self.param_index_observable.value
end

function xStream:set_param_index(val)
  self.param_index_observable.value = val
end

-------------------------------------------------------------------------------

function xStream:get_clear_undefined()
  return self.clear_undefined_observable.value
end

function xStream:set_clear_undefined(val)
  self.clear_undefined_observable.value = val
end

-------------------------------------------------------------------------------

function xStream:get_include_hidden()
  return self.include_hidden_observable.value
end

function xStream:set_include_hidden(val)
  self.include_hidden_observable.value = val
end

-------------------------------------------------------------------------------

function xStream:get_expand_columns()
  return self.expand_columns_observable.value
end

function xStream:set_expand_columns(val)
  self.expand_columns_observable.value = val
end

-------------------------------------------------------------------------------

function xStream:get_mute_mode()
  return self.mute_mode_observable.value
end

function xStream:set_mute_mode(val)
  self.mute_mode_observable.value = val
end

-------------------------------------------------------------------------------

function xStream:get_muted()
  return self.muted_observable.value
end

function xStream:set_muted(val)
  TRACE("xStream:set_muted(val)",val)

  local changed = (val ~= self.muted_observable.value)
  self.muted_observable.value = val

  if not changed then
    return
  end

  if not val then
    return
  end

  -- we have muted the track 
  -- stop output and (optionally) write OFF across columns

  self:wipe_futures()

  local line = self._writepos.lines_travelled
  if rns.transport.playing then
    line = line+2
  end
  self.mute_pos = line

  local function produce_note_off()
    local note_cols = {}
    local note_col_count = self:get_visible_note_cols()
    for i = 1,note_col_count do
      table.insert(note_cols,{
        note_value = xNoteColumn.NOTE_OFF_VALUE,
        instrument_value = xLinePattern.EMPTY_VALUE,
        volume_value = xLinePattern.EMPTY_VALUE,
        panning_value = xLinePattern.EMPTY_VALUE,
        delay_value = 0,
      })
    end
    return note_cols
  end

  local xline = {}

  if (self.mute_mode == xStream.MUTE_MODE.OFF) then
    xline.note_columns = produce_note_off()
  end

  local mute_xline = xLine(xline)
  self.buffer[self.mute_pos] = mute_xline
  self.buffer[self.mute_pos+1] = mute_xline
  self.highest_buffer_idx = math.max(self.mute_pos+1,self.highest_buffer_idx)

  self:do_output(self._writepos)

end

-------------------------------------------------------------------------------

function xStream:get_active()
  return self.active_observable.value
end

function xStream:set_active(val)
  self.active_observable.value = val
end

-------------------------------------------------------------------------------
-- will produce output for the next number of lines
-- @param xpos (xSongPos), needs to be a valid position in the song
-- @param num_lines (int), use writeahead if not defined
-- @param live_mode (bool), skip playpos when true

function xStream:do_output(xpos,num_lines,live_mode)
  TRACE("xStream:do_output(xpos)",xpos,num_lines,live_mode)

  if not self.selected_model then
    return
  end

  if not num_lines then
    num_lines = rns.transport.playing and self.writeahead or 1
  end

  -- purge old content from buffers
  self:wipe_past()

  -- generate new content as needed
  if not self.muted then
    local has_content,missing_from = 
      self:has_content(xpos.lines_travelled,num_lines-1)
    if not has_content then
      self:get_content(
        missing_from,num_lines-(missing_from-xpos.lines_travelled),xpos)
    end
  end

  local tmp_pos -- temp line-by-line position

  -- TODO decide this elsewhere (optimize)
  local patt_num_lines = xSongPos.get_pattern_num_lines(xpos.sequence)

  local param = nil
  local phrase = nil
  local ptrack_auto = nil
  local last_auto_seq_idx = nil

  -- TODO decide this elsewhere (optimize)
  local able_to_write_automation = 
    (self.device and (self.param_index) > 0) and true or false

  -- expand columns only when we have manually defined them
  -- (existing pattern-data is a full 12 note columns...)
  local expand_columns = self.expand_columns and
    self.selected_model.user_redefined_xline

  for i = 0,num_lines-1 do
    tmp_pos = xSongPos({sequence=xpos.sequence,line=xpos.line+i})
    tmp_pos.bounds_mode = self.bounds_mode
    if (tmp_pos.line > patt_num_lines) then
      -- exceeded pattern
      if (self.loop_mode ~= xSongPos.LOOP_BOUNDARY.NONE) then
        -- normalize the songpos and redial 
        --print("*** exceeded pattern PRE",tmp_pos,num_lines-i)
        tmp_pos.lines_travelled = xpos.lines_travelled + i - 1
        tmp_pos:normalize()
        --print("*** exceeded pattern POST",tmp_pos,num_lines-i)
        self:do_output(tmp_pos,num_lines-i)
      end
      return
    else
      local cached_line = tmp_pos.line
      if rns.transport.loop_block_enabled and 
        (self.block_mode ~= xSongPos.BLOCK_BOUNDARY.NONE) 
      then
        tmp_pos.line = tmp_pos:enforce_block_boundary("increase",xpos.line,i)
        if (cached_line ~= tmp_pos.line) then
          -- exceeded block loop, redial with new position
          tmp_pos.lines_travelled = xpos.lines_travelled + i
          --print("*** exceeded block loop",tmp_pos,num_lines-i)
          self:do_output(tmp_pos,num_lines-i)
          return
        end
      end

      if live_mode and (tmp_pos.line+1 == rns.transport.playback_pos.line) then
        --print("*** skip output",xpos.lines_travelled+i,tmp_pos)
      else
        --print("*** write output",xpos.lines_travelled+i,tmp_pos)
        
        local pos_line = xpos.lines_travelled+i
        local xline = nil

        if self.muted and (pos_line > self.mute_pos+1) then
          --print("*** mute output - pos_line",pos_line)
          xline = self.empty_xline
        else
          -- normal output
          --print("*** normal output - pos_line,tmp_pos",pos_line,tmp_pos)
          xline = self.buffer[pos_line]
          -- check if we need to resolve automation
          if able_to_write_automation and xline.automation then
            if (tmp_pos.sequence ~= last_auto_seq_idx) then
              last_auto_seq_idx = tmp_pos.sequence
              --print("*** last_auto_seq_idx",last_auto_seq_idx)
              ptrack_auto,param = self:resolve_automation(tmp_pos.sequence)
            end
          end
          --print("*** ptrack_auto",ptrack_auto)
          if ptrack_auto then
            --print("param.value_quantum",param.value_quantum)
            if (param.value_quantum == 0) then
              ptrack_auto.playmode = self.automation_playmode
            end
          end
        end

        --print("*** do_write - pos_line,xline",pos_line,xline) --,xline.note_columns[1].note_value)
        if xline then
          xline:do_write(
            tmp_pos.sequence,
            tmp_pos.line,
            self.track_index,
            phrase,
            ptrack_auto,
            patt_num_lines,
            self.selected_model.output_tokens,
            self.include_hidden,
            self.expand_columns,
            self.clear_undefined)
        else
          LOG("WARNING Missing xline on output",tmp_pos,xpos.lines_travelled)
        end
      end

    end    
  end

end

-------------------------------------------------------------------------------
-- check if buffer has content for the specified range
-- @param pos (int), index in buffer 
-- @param num_lines (int)
-- @return bool, true when all content is present
-- @return int, (when not present) the first missing index 

function xStream:has_content(pos,num_lines)
  TRACE("xStream:has_content(pos,num_lines)",pos,num_lines)

  for i = pos,pos+num_lines do
    if not (self.buffer[i]) then
      --print("*** has_content - missing from",i)
      return false,i
    end
  end

  return true

end

-------------------------------------------------------------------------------
-- retrieve content from our callback method + pattern
-- @param pos (int), internal line count
-- @param num_lines (int) 
-- @param xpos (xSongPos) read from this position (when not previously read)
-- @return table<xLine>

function xStream:get_content(pos,num_lines,xpos)
  TRACE("xStream:get_content(pos,num_lines)",pos,num_lines)

  if not self.selected_model.callback then
    error("No callback method has been specified")
  end

  local read_pos = nil
  if self.next_read_pos then
    read_pos = self.next_read_pos
    --print("*** read_pos - self.next_read_pos",self.next_read_pos)
  else
    read_pos = xSongPos(xpos)
    --print("*** read_pos - xSongPos(xpos)",xpos)
  end

  for i = 0, num_lines-1 do
    local line_index = pos+i
    local phrase = nil -- TODO associate a phrase 
    -- pattern data can be written multiple times due to arguments 
    -- being changed, but reading from the pattern should only
    -- be performed once - 
    local xline
    local has_read_buffer = self.read_buffer[line_index]
    if has_read_buffer then 
      xline = self.read_buffer[line_index]
    else
      xline = xLine.do_read(
        read_pos.sequence,read_pos.line,self.include_hidden,self.track_index,phrase)
      self.read_buffer[line_index] = table.rcopy(xline) -- TODO rcopy needed ?
      --print("*** xStream:get_content - read_pos",read_pos,"line_index",line_index,"note_cols...",rprint(xline.note_columns))
    end
    --print("IN  ",line_index,read_pos,xline.note_columns[1].note_string)

    local success,err = pcall(function()
      self.buffer[line_index] = 
        self.selected_model.callback(line_index,xLine(xline),xSongPos(read_pos))
    end)
    if err then
      LOG("ERROR: please review callback function - "..err)
      -- TODO display runtime errors separately (runtime_status)
      self.callback_status_observable.value = err
      self.buffer[line_index] = xLine({})
    else
      -- we might have redefined the xline (or parts of it) in our  
      -- callback method - convert everything into class instances...
      self.buffer[line_index] = xLine.apply_descriptor(self.buffer[line_index])
    end
    --print("*** xStream:get_content - callback evaluated for line_index",line_index,rprint(self.buffer[line_index].note_columns),rprint(self.buffer[line_index].pattern_line.note_columns))
    self.highest_buffer_idx = math.max(line_index,self.highest_buffer_idx)

    if not has_read_buffer then
      read_pos:increase_by_lines(1)
    end

  end

  self.next_read_pos = read_pos

end

-------------------------------------------------------------------------------
-- get visible note columns in the associated track
-- @return int

function xStream:get_visible_note_cols()
  TRACE("xStream:get_visible_note_cols()")

  local track = rns.tracks[self.track_index]
  assert(track,"Trying to access a non-existing track")

  return track.visible_note_columns

end

-------------------------------------------------------------------------------
-- get visible note columns in the associated track
-- @return int

function xStream:get_visible_effect_cols()
  TRACE("xStream:get_visible_effect_cols()")

  local track = rns.tracks[self.track_index]
  assert(track,"Trying to access a non-existing track")

  return track.visible_effect_columns

end

-------------------------------------------------------------------------------
-- resolve (or create) automation for parameter in the provided seq-index
-- can return nil if trying to create automation on non-automateable parameter
-- note: automation is per-pattern, changes as we move through the sequence
-- @param seq_idx (int)
-- @return renoise.PatternTrackAutomation or nil

function xStream:resolve_automation(seq_idx)
  TRACE("xStream:resolve_automation(seq_idx)",seq_idx)
 
  local patt_idx = rns.sequencer:pattern(seq_idx)
  local patt = rns.patterns[patt_idx]
  assert(patt,"Could not find pattern")
  local param = self.device.parameters[self.param_index]
  assert(param,"Could not find device parameter")

  if not param.is_automatable then
    return
  end

  local ptrack = patt.tracks[self.track_index]
  assert(ptrack,"Could not find pattern-track")

  local automation = ptrack:find_automation(param)
  
  -- create if not present 
  if not automation then
    automation = ptrack:create_automation(param)
  end

  return automation,param

end

-------------------------------------------------------------------------------
-- clear various buffers, prepare for new output

function xStream:reset()
  TRACE("xStream:reset()")

  if self.manage_gc then
    collectgarbage("stop")
  else
    --collectgarbage("restart")
    --collectgarbage()
  end

  self.buffer = {}
  self.highest_buffer_idx = 0
  self.lowest_buffer_idx = 0
  self.read_buffer = {}
  self.next_read_pos = nil

  -- revert data to initial state
  if self.selected_model then
    self.selected_model.env.data = 
      table.rcopy(self.selected_model.data_initial)
  end

end

-------------------------------------------------------------------------------
-- activate live streaming 

function xStream:start()
  TRACE("xStream:start()")

  self:reset()
  self.active = true

  if rns.transport.playing then
    if not self.just_started_playback then
      -- when already playing, start from next line
      self._writepos = xSongPos(rns.transport.playback_pos)
      self._writepos.lines_travelled = -1
      self._writepos:increase_by_lines(1)
    else
      self._writepos = xSongPos(rns.transport.playback_pos)
    end
    self:do_output(self._writepos)
  else
    self._writepos = xSongPos(rns.transport.edit_pos)
    self:do_output(self._writepos)
  end

end

-------------------------------------------------------------------------------
-- activate live streaming and begin playback
-- (use this method instead of the native Renoise functionality in order 
-- to make the first line play back - otherwise it's too late...)

function xStream:start_and_play()
  TRACE("xStream:start_and_play()")

  if not rns.transport.playing then
    rns.transport.playback_pos = rns.transport.edit_pos
  end

  self:start()
  rns.transport:start_at(self._writepos.line)
  self.just_started_playback = os.clock()

end

-------------------------------------------------------------------------------
-- stop live streaming

function xStream:stop()
  TRACE("xStream:stop()")

  self.active = false

  if self.manage_gc then
    collectgarbage("restart")
    collectgarbage()
  end

end

-------------------------------------------------------------------------------
-- mute output, but continue progression in the background
-- @param mute_mode (xStream.MUTE_MODE)

function xStream:mute(mute_mode)
  TRACE("xStream:mute(mute_mode)",mute_mode)

  if mute_mode then
    self.mute_mode = mute_mode
  end

  -- the rest is handled by set_muted()
  self.muted = true

end

-------------------------------------------------------------------------------
-- unmute output, when already muted

function xStream:unmute()

  -- the rest is handled by set_muted()
  self.muted = false

end

-------------------------------------------------------------------------------
-- schedule start, make something to happen at a specific position
-- @param pos (SongPos), start position 
-- @param fn (function), optional - method to evaluate
--  use this to define a new callback method, or change arguments

function xStream:schedule(pos,fn)
  TRACE("xStream:start(pos)",pos,fn)

  -- TODO schedule events (start, stop etc.)

end

-------------------------------------------------------------------------------
-- Update the write position as a result of a changed playback position.
-- Most of the time we want the stream to continue smoothly forward - this is
-- true for any kind of pattern, sequence or block loop. However, when we
-- detect 'user' events, the position can also jump backwards (the detection
-- of these events is not entirely reliable near loop boundaries)
-- @param pos, renoise.SongPos

function xStream:set_pos(pos)
  TRACE("xStream:set_pos(pos)",pos)

  if not self.active then
    return
  end

  local num_lines = 0
  local near_lines_def = self.writeahead

  local near_top = function(line)
    return (line <= near_lines_def) and true or false
  end

  local near_end = function(line,patt_lines)
    return (line >= (patt_lines-near_lines_def))
  end

  if (pos.sequence == self._playpos.sequence) then
    -- within same pattern
    if (pos.line < self._playpos.line) then
      -- earlier line in pattern
      --print("*** same pattern, wrap around ------------------------------------------")

      local num_lines, xblock, block_num_lines
      if rns.transport.loop_block_enabled then
        xblock = xBlockLoop.get()
        block_num_lines = xblock.end_line - xblock.start_line + 1
      end

      local patt_num_lines = xSongPos.get_pattern_num_lines(self._playpos.sequence)
      if near_top(pos.line) and near_end(self._playpos.line,patt_num_lines) then
        -- conclusion: pattern loop
        num_lines = (patt_num_lines-self._playpos.line) + pos.line
        self._writepos:increase_by_lines(num_lines)
        --print("*** *** same pattern, wrap around - pattern loop",num_lines)
      elseif rns.transport.loop_block_enabled and
        near_top(pos.line-xblock.start_line) and 
          near_end(xblock.end_line-xblock.start_line,block_num_lines)
      then
        -- conclusion: block loop
        num_lines = (xblock.end_line-self._playpos.line) + (pos.line-xblock.start_line) + 1
        self._writepos:increase_by_lines(num_lines)

        --print("*** same pattern, wrap around - loop block",block_num_lines,num_lines)
      else
        -- conclusion: user navigation
        -- will repeat/rewind to earlier position 
        num_lines = self._playpos.line - pos.line
        self._writepos:decrease_by_lines(num_lines)
        --print("*** same pattern, wrap around - user - pos",pos,"self._playpos",self._playpos)
      end

    elseif (pos.line > self._playpos.line) then
      -- normal progression through pattern
      self._writepos:increase_by_lines(pos.line - self._playpos.line)
      --print("*** same pattern, self._writepos POST",pos.line - self._playpos.line,self._writepos)
    end
  elseif (pos.sequence < self._playpos.sequence) then
    -- earlier pattern, usually caused by seq-loop or song boundary
      --print("*** earlier pattern ------------------------------------------")

    local patt_num_lines = xSongPos.get_pattern_num_lines(self._playpos.sequence)

    -- the old position is near the end of the pattern
    -- use the writeahead as the basis for this calculation

    if (self._playpos.line >= (patt_num_lines-near_lines_def)) then
      -- conclusion: we've reached the end of the former pattern 
      -- difference is the remaning lines in old position plus the current line 
      local num_lines = (patt_num_lines-self._playpos.line)+pos.line
      self._writepos:increase_by_lines(num_lines)
      self._writepos.sequence = pos.sequence
      --print("earlier pattern - end of former pattern - increase by lines",num_lines,pos,self._playpos)
    else
      -- conclusion: we've changed the position manually, somehow
      -- disregard the sequence and just use the lines
      local num_lines = pos.line-self._playpos.line
      self._writepos:increase_by_lines(num_lines)
      self._writepos.sequence = pos.sequence
      --print("earlier pattern - changed manually - increase by lines",num_lines,pos,self._playpos)
    end

  else
    -- later pattern
    --print("next pattern, pos,self._playpos",pos,self._playpos)
    local num_lines = xSongPos.get_line_diff(pos,self._playpos)
    self._writepos:increase_by_lines(num_lines)
    --print("next pattern, calculate num_lines",num_lines)

  end
  
  local msg = "*** self._writepos:"..tostring(self._writepos)
    ..",lines_travelled:"..tostring(self._writepos.lines_travelled)
    --..",memory used"..collectgarbage("count")
  renoise.app():show_status(msg)
  --print(msg)

  self:do_output(self._writepos,nil,true)


end

-------------------------------------------------------------------------------
-- forget all output ahead of our current write-position
-- method is automatically called when callback arguments have changed,
-- and will cause fresh line(s) to be created in the next cycle
-- (see also xStreamArgs)

function xStream:wipe_futures()
  TRACE("xStream:wipe_futures()")

  -- do not wipe while muted
  if self.muted then
    return
  end

  local from_idx = self._writepos.lines_travelled
  if rns.transport.playing then
    -- when live streaming, exclude current line
    from_idx = from_idx+1
  end

  for i = from_idx,self.highest_buffer_idx do
    self.buffer[i] = nil
    --print("*** wiped buffer at",i)
  end

  self.highest_buffer_idx = self._writepos.lines_travelled
  --print("*** self.highest_buffer_idx",self.highest_buffer_idx)

end

-------------------------------------------------------------------------------
-- wipe all data behind our current write-position
-- (see also xStreamArgs)

function xStream:wipe_past()
  TRACE("xStream:wipe_past()")

  local from_idx = self._writepos.lines_travelled - 1
  for i = from_idx,self.lowest_buffer_idx,-1 do
    self.buffer[i] = nil
    self.read_buffer[i] = nil
    --print("*** wipe_past - cleared buffers at ",i)
  end

  self.lowest_buffer_idx = from_idx
  --print("lowest_buffer_idx ",from_idx)

end

--------------------------------------------------------------------------------
-- decide the writeahead amount, depending on the song tempo

function xStream:determine_writeahead()
  TRACE("xStream:determine_writeahead()")

  local bpm = rns.transport.bpm
  local lpb = rns.transport.lpb

  self.writeahead = math.ceil(math.max(2,(bpm*lpb)/self.writeahead_factor))
  --self.writeahead = 4
  --print("xStream.writeahead",self.writeahead)


end

-------------------------------------------------------------------------------
-- perform periodic updates

function xStream:on_idle()
  --TRACE("xStream:on_idle()")

  -- user interface 
  if self.ui then
    self.ui:on_idle()
  end

  -- track changes to callback, poll arguments
  if self.selected_model then
    self.selected_model:on_idle()
  end

  -- track the current play/edit position
  local playpos = rns.transport.playback_pos
  local editpos = rns.transport.edit_pos
  if rns.transport.playing then
    if self.just_started_playback then
      if (0.2 > (os.clock() - self.just_started_playback)) then
        self.just_started_playback = nil
        --print("just_started_playback gone...")
      end
    else
      if (playpos ~= self._playpos) then
        --print("on_idle - playpos changed...",playpos,self._playpos)
        self:set_pos(playpos)
      end
    end
  else
    -- paused playback, do not output 
  end
  if not self.just_started_playback then
    self._playpos = playpos
    self._editpos = editpos
  end

end

-------------------------------------------------------------------------------
-- call when a new document becomes available

function xStream:attach_to_song()
  TRACE("xStream:attach_to_song()")

  self:stop()

  -- handling changes via observable is quicker than idle notifier
  local pattern_index_notifier = function()
    --print("pattern_index_notifier fired...")
    local playpos = rns.transport.playback_pos
    self:set_pos(playpos)
    self._playpos = playpos
  end
  rns.selected_pattern_index_observable:add_notifier(pattern_index_notifier)

  -- track when tempo has changed
  local tempo_notifier = function()
    self:determine_writeahead()
  end
  rns.transport.bpm_observable:add_notifier(tempo_notifier)
  rns.transport.lpb_observable:add_notifier(tempo_notifier)

  -- track when song is started and stopped
  local playing_notifier = function()
    --print("xStream playing_notifier fired...")
    if rns.transport.playing then
      self.just_started_playback = os.clock()
      self._playpos = rns.transport.playback_pos
    end
  end
  rns.transport.playing_observable:add_notifier(playing_notifier)


end

-------------------------------------------------------------------------------
-- fill pattern-track in selected pattern
 
function xStream:fill_track()
  TRACE("xStream:fill_track()")
  
  local patt_num_lines = xSongPos.get_pattern_num_lines(rns.selected_sequence_index)
  self:apply_to_range(1,patt_num_lines)

end

-------------------------------------------------------------------------------
-- ensure that selection is valid (not spanning multiple tracks)
-- @return bool
 
function xStream:validate_selection()
  TRACE("xStream:validate_selection()")

  local sel = rns.selection_in_pattern
  if not sel then
    return false,"Please create a (single-track) selection in the pattern"
  end
  if (sel.start_track ~= sel.end_track) then
    return false,"Selection must start and end in the same track"
  end

  return true

end

-------------------------------------------------------------------------------
-- fill pattern-track in selected pattern
-- @param locally (bool) relative to the top of the pattern
 
function xStream:fill_selection(locally)
  TRACE("xStream:fill_selection(locally)",locally)

  local passed,err = self.validate_selection()
  if not passed then
    renoise.app():show_warning(err)
    return
  end

  local num_lines = xSongPos.get_pattern_num_lines(rns.selected_sequence_index)
  local from_line = rns.selection_in_pattern.start_line
  local to_line = rns.selection_in_pattern.end_line
  local travelled = (not locally) and (from_line-1) or 0 

  -- backup settings
  local cached_track_index = self.track_index

  -- write output
  self.track_index = rns.selection_in_pattern.start_track
  self:apply_to_range(from_line,to_line,travelled)

  -- restore settings
  self.track_index = cached_track_index

end

-------------------------------------------------------------------------------
-- apply the callback to a range in the selected pattern,  
-- temporarily switching to a different set of buffers
-- @param from_line (int)
-- @param to_line (int) 
-- @param travelled (int) where the callback 'started', use from_line if nil

function xStream:apply_to_range(from_line,to_line,travelled)
  TRACE("xStream:apply_to_range(from_line,to_line,travelled)",from_line,to_line,travelled)

  local xpos = xSongPos({
    sequence = rns.transport.edit_pos.sequence,
    line = from_line
  })
  if travelled then
    xpos.lines_travelled = travelled
  end
  -- ignore any kind of loop (realtime only)
  xpos.out_of_bounds = xSongPos.OUT_OF_BOUNDS.CAP
  xpos.block_boundary = xSongPos.BLOCK_BOUNDARY.NONE
  xpos.loop_boundary = xSongPos.LOOP_BOUNDARY.NONE

  local live_mode = false -- start from first line
  local num_lines = to_line-from_line+1

  self:reset()

  -- backup settings
  local cached_active = self.active
  local cached_buffer = self.buffer
  local cached_read_buffer = self.read_buffer
  local cached_next_read_pos = self.next_read_pos
  local cached_bounds_mode = self.bounds_mode
  local cached_block_mode = self.block_mode
  local cached_loop_mode = self.loop_mode

  -- write output
  self.active = true
  self.bounds_mode = xpos.out_of_bounds
  self.block_mode = xpos.block_boundary
  self.loop_mode = xpos.loop_boundary
  self:do_output(xpos,num_lines,live_mode)

  -- restore settings
  self.active = cached_active
  self.buffer = cached_buffer
  self.read_buffer = cached_read_buffer
  self.next_read_pos = cached_next_read_pos
  self.bounds_mode = cached_bounds_mode
  self.block_mode = cached_block_mode
  self.loop_mode = cached_loop_mode

end

-------------------------------------------------------------------------------
-- take the current buffer and create an instrument phrase from it
-- instrument numbers are treated as sample indices - this might not be what
-- you expect, if you enable sample columns in the resulting phrase

function xStream:export_to_phrase(instr_idx)
  TRACE("xStream:export_to_phrase(instr_idx)",instr_idx)

  if table.is_empty(self.buffer) then
    renoise.app():show_message("There is no recording to export")
    return
  end

  local xphrase_mgr = xPhraseMgr()
  xphrase_mgr.default_range = 6
  xphrase_mgr.instr_idx = instr_idx

  local note_range,phrase_idx = xphrase_mgr:get_available_slot()
  --print("note_range,phrase_idx",rprint(note_range),phrase_idx)
  if not note_range then
    LOG("Failed to allocate a phrase (no more room left?)")
  end

  local num_lines = math.min(512,self.highest_buffer_idx)
  TRACE("num_lines",num_lines)

  local instr = rns.instruments[xphrase_mgr.instr_idx]
  local phrase = instr:insert_phrase_at(phrase_idx)
  assert(phrase,"Failed to create phrase")
  phrase.mapping.note_range = {
    note_range[1],
    note_range[2]
  }
  phrase.mapping.base_note = note_range[1]
  phrase:clear() -- remove the default C-4 note

  for i = 0,num_lines-1 do
    if (self.buffer[i]) then
      self.buffer[i]:do_write(
        {line = i+1},
        nil, -- track_index
        phrase,
        nil, -- ptrack_auto
        nil,  -- patt_num_lines
        self.selected_model.output_tokens,
        self.include_hidden,
        self.expand_columns,
        self.clear_undefined)
    end
  end

  phrase.number_of_lines = num_lines
  rns.selected_phrase_index = phrase_idx

end


-------------------------------------------------------------------------------
-- save to file, using an internal representation of the recording
-- will prompt you for a location & file name

function xStream:export_to_file()
  TRACE("xStream:export_to_file()")

  if table.is_empty(self.buffer) then
    renoise.app():show_message("There is no recording to export")
    return
  end

  local file_path = renoise.app():prompt_for_filename_to_write("xml", "Export stream as...")
  --print("file_path",file_path)

  -- TODO export session to file


end


